# Implementation

OpenSCAD2 has a somewhat different implementation than OpenSCAD1.
The main difference is the addition of new stages to the translator,
which are the Analyzer and Coder.
Also, the data transmitted between each stage has changed.
```
Lexer
--tokens--> Parser
            --parse-tree--> Analyzer
                            --AST--> Upgrade Tool
                            --AST--> Coder
                                     --code--> Evaluator
                                               --csg-tree--> Preview
                                               --csg-tree--> Render
```

## Lexer
The Lexer produces a stream of tokens, as before.
Changes:
* The implementation of `include`.
  Previously, the Lexer interpolated the contents of the included file
  into the token stream. Now included scripts are not opened until the Analyzer stage.
* Every token has the preceding white space attached to it.
  The EOF token contains the final trailing whitespace.
  The token stream now contains enough information to exactly reproduce the original source text.
  This is used by the [syntax upgrade tool](Backwards_Compatibility.md#upgrade-tool).

## Parser
The Parser is still written in Bison, but the grammar is a complete rewrite.
The grammar is somewhat vaguer than before. For example, we previously encoded
the syntax of list comprehensions in the grammar. Now, list comprehensions are just
expressions, and syntactic restrictions on where `for` can occur are now enforced
by the Analyzer.

The output is a parse tree which is no longer intended to be executed, but which
is instead fed to the analyzer. The parse tree now contains all of the original tokens from the token stream,
so it can be used by the upgrade tool to reproduce the original source text.

## Analyzer
The Semantic Analyzer performs semantic analysis of the parse tree,
figures out the meaning of the program, and annotates the parse tree,
producing an AST, or annotated syntax tree.

The Analyzer is responsible for enforcing context sensitive syntax restrictions,
issuing syntax errors when these are violated.
The Analyzer looks up all identifiers and determines which definition binds them,
and reports errors about undefined or multiply defined names.
It implements the `include` and `use` operators, opening the referenced script
file and analyzing them to determine which bindings are imported.
The Analyzer performs a global analysis on the script to determine if it
is OpenSCAD1 (3 namespaces) or OpenSCAD2 (1 namespace), and annotates the
parse tree according to whether we are using backward compatibility mode
or OpenSCAD2 runtime semantics.

The AST produced by the analyzer is used by the upgrade tool to upgrade a script
to OpenSCAD2 syntax and produce the modified text file.

## Coder

The Coder or Code Generator takes the AST and generates executable
code for the Evaluator. It figures out the run time data structures
needed to represent local and global variables, and converts bound
identifiers into indexes into the appropriate run time environment table.
The output is an executable code tree.

## Evaluator
The input of the evaluator is different from before.
It's no longer a raw parse tree straight out of Bison,
but instead is an executable code tree generated by the Coder.

The output of the evaluator is the CSG tree, but it
is now represented as a Value.
