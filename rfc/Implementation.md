# Implementation

OpenSCAD2 has a somewhat different implementation than OpenSCAD1.
The main difference is the addition of a new stage into the translator,
which is the Analyzer. Also, the data transmitted between each stage has
changed somewhat.
```
Lexer --tokens--> Parser --parse-tree--> Analyzer --code--> Evaluator --csg-tree--> Preview or Render
```

## Lexer
The Lexer produces a stream of tokens, as before.
The biggest change is in the implementation of `include`.
Previously, the Lexer interpolated the contents of the included file
into the token stream. Now included scripts are not opened until the Analyzer stage.

## Parser
The Parser is still written in Bison, but the grammar is a complete rewrite.
The grammar is somewhat vaguer than before. For example, we previously encoded
the syntax of list comprehensions in the grammar. Now, list comprehensions are just
expressions, and syntactic restrictions on where `for` can occur are now enforced
by the Analyzer.

The output is a parse tree which is no longer intended to be executed, but which
is instead fed to the analyzer.

## Analyzer
The Analyzer is new.
It is responsible for enforcing context sensitive syntax restrictions,
issuing syntax errors when these are violated. Scoping of variables is
figured out by the Analyzer, which now contains a simple code generator
where variable names are replaced by slot indexes into some kind of run
time environment structure. The Analyzer performs a global analysis on
a script, and decides whether to compile it in backward compatibility mode
(with 3 namespaces) or modern mode (with 1 namespace), generating different
code for the two cases.

## Evaluator
The input of the evaluator is different from before.
It's no longer a raw parse tree straight out of Bison,
but instead is an executable code tree generated by the Analyzer.

The output of the evaluator is the CSG tree, but it
is now represented as a Value.
